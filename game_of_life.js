// Generated by CoffeeScript 1.6.3
/*
Toshiro Ken Sugihara 2013
*/


(function() {
  $(function() {
    /* Variables*/

    var alive_color, calculateIfCellAlive, canvas_height, canvas_width, determineNextGenerationCellStates, generateWorld, num_columns, num_rows, paper, paused, populateWorld, runWorld, tick_interval, updateCells, updateWorld, world;
    num_rows = 30;
    num_columns = 48;
    canvas_width = 480;
    canvas_height = 300;
    paused = false;
    tick_interval = 50;
    paper = Raphael("canvas", canvas_width, canvas_height);
    alive_color = "#50c0a8";
    world = [];
    /* Functions*/

    generateWorld = function() {
      var createRaphaelCell, createRaphaelGrid, i, row, _i, _j;
      world.getCellByCoord = function(row, column) {
        var cell_id_string;
        cell_id_string = "cell_" + row + "_" + column;
        return $("#" + cell_id_string);
      };
      world.drawCell = function(row, column, alive) {
        var cell;
        cell = this.getCellByCoord(row, column);
        if (alive) {
          return cell.attr({
            fill: alive_color
          });
        } else {
          return cell.attr({
            fill: "#ffffff"
          });
        }
      };
      world.draw = function() {
        var j, k, _i, _results;
        _results = [];
        for (j = _i = 0; 0 <= num_rows ? _i < num_rows : _i > num_rows; j = 0 <= num_rows ? ++_i : --_i) {
          _results.push((function() {
            var _j, _results1;
            _results1 = [];
            for (k = _j = 0; 0 <= num_columns ? _j < num_columns : _j > num_columns; k = 0 <= num_columns ? ++_j : --_j) {
              _results1.push(this.drawCell(j, k, world[j][k].alive));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };
      createRaphaelCell = function(row, column, height, width) {
        var cell;
        cell = paper.rect(column * width, row * height, width, height);
        cell.node.id = "cell_" + row + "_" + column;
        return cell.attr({
          stroke: "#d8d8d8"
        }).data("row", row).data("column", column).click(function() {
          var cell_data;
          cell_data = world[this.data("row")][this.data("column")];
          cell_data.alive = !cell_data.alive;
          if (cell_data.alive) {
            return this.attr({
              fill: alive_color
            });
          } else {
            return this.attr({
              fill: "#ffffff"
            });
          }
        });
      };
      for (i = _i = 0; 0 <= num_rows ? _i < num_rows : _i > num_rows; i = 0 <= num_rows ? ++_i : --_i) {
        row = [];
        for (_j = 0; 0 <= num_columns ? _j < num_columns : _j > num_columns; 0 <= num_columns ? _j++ : _j--) {
          row.push({
            alive: false
          });
        }
        world.push(row);
      }
      return (createRaphaelGrid = function() {
        var grid_cell_height, grid_cell_width, j, k, _k, _results;
        grid_cell_height = canvas_height / num_rows;
        grid_cell_width = canvas_width / num_columns;
        _results = [];
        for (j = _k = 0; 0 <= num_rows ? _k < num_rows : _k > num_rows; j = 0 <= num_rows ? ++_k : --_k) {
          _results.push((function() {
            var _l, _results1;
            _results1 = [];
            for (k = _l = 0; 0 <= num_columns ? _l < num_columns : _l > num_columns; k = 0 <= num_columns ? ++_l : --_l) {
              _results1.push(createRaphaelCell(j, k, grid_cell_height, grid_cell_width));
            }
            return _results1;
          })());
        }
        return _results;
      })();
    };
    populateWorld = function() {
      world[0][8].alive = true;
      world[1][9].alive = true;
      world[2][9].alive = true;
      world[2][8].alive = true;
      world[2][7].alive = true;
      world[13][22].alive = true;
      world[14][21].alive = true;
      world[14][23].alive = true;
      world[15][21].alive = true;
      world[15][23].alive = true;
      world[16][22].alive = true;
      return world[16][23].alive = true;
    };
    calculateIfCellAlive = function(row, column) {
      var count, countNeighbors, wrapped;
      wrapped = function(point, dimension_size) {
        switch (false) {
          case !(point < 0):
            return dimension_size - 1;
          case !(point >= dimension_size):
            return 0;
          default:
            return point;
        }
      };
      countNeighbors = function() {
        var cell_column, cell_row, column_position, count, rel_positions, row_position, _i, _j, _len, _len1;
        count = 0;
        rel_positions = [-1, 0, 1];
        for (_i = 0, _len = rel_positions.length; _i < _len; _i++) {
          row_position = rel_positions[_i];
          for (_j = 0, _len1 = rel_positions.length; _j < _len1; _j++) {
            column_position = rel_positions[_j];
            if (!(row_position === 0 && column_position === 0)) {
              cell_row = wrapped(row + row_position, num_rows);
              cell_column = wrapped(column + column_position, num_columns);
              count += (world[cell_row][cell_column].alive ? 1 : 0);
            }
          }
        }
        return count;
      };
      count = countNeighbors();
      if (world[row][column].alive) {
        return (2 <= count && count <= 3);
      } else {
        return count === 3;
      }
    };
    determineNextGenerationCellStates = function() {
      var arr, grid, j, k, _i, _j, _ref, _ref1;
      grid = [];
      for (j = _i = 0, _ref = world.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        arr = [];
        for (k = _j = 0, _ref1 = world[j].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; k = 0 <= _ref1 ? ++_j : --_j) {
          arr.push(calculateIfCellAlive(j, k));
        }
        grid.push(arr);
      }
      return grid;
    };
    updateCells = function(results_grid) {
      var arr, j, k, _i, _ref, _results;
      _results = [];
      for (j = _i = 0, _ref = results_grid.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        arr = [];
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (k = _j = 0, _ref1 = results_grid[j].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; k = 0 <= _ref1 ? ++_j : --_j) {
            _results1.push(world[j][k].alive = results_grid[j][k]);
          }
          return _results1;
        })());
      }
      return _results;
    };
    updateWorld = function() {
      var results_grid;
      world.draw();
      results_grid = determineNextGenerationCellStates();
      return updateCells(results_grid);
    };
    /* Main*/

    $(window).keydown(function(event) {
      if (event.keyCode === 80) {
        if (paused) {
          paused = !paused;
          return runWorld();
        } else {
          return paused = !paused;
        }
      }
    });
    generateWorld();
    populateWorld();
    return (runWorld = function() {
      updateWorld();
      if (!paused) {
        return setTimeout(runWorld, tick_interval);
      }
    })();
  });

}).call(this);
